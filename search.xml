<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>实现数组去重的 9 种高阶方法</title>
      <link href="/2021/11/01/shu-zu-qu-chong-de-9-chong-gao-jie-fang-fa/"/>
      <url>/2021/11/01/shu-zu-qu-chong-de-9-chong-gao-jie-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>题目：给定一个数组 [1,2,2,4,null,null,’3’,’abc’,3,5,4,1,2,2,4,null,null,’3’,’abc’,3,5,4] 去除重复项。</p><pre class="line-numbers language-none"><code class="language-none">let arr &#x3D;  [1,2,2,4,null,null,&#39;3&#39;,&#39;abc&#39;,3,5,4,1,2,2,4,null,null,&#39;3&#39;,&#39;abc&#39;,3,5,4]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><h3 id="1-利用对象的key唯一"><a href="#1-利用对象的key唯一" class="headerlink" title="1. 利用对象的key唯一"></a>1. 利用对象的key唯一</h3><p>对象的key不可重复，否则后者会覆盖前者。利用该特性，实现数组去重，遍历数组，将数组的每一项作为对象的key值。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">let obj &#x3D; &#123;&#125;for(let i &#x3D; 0; i &lt; arr.length; i++) &#123;  let item &#x3D; arr[i]  if(obj[item] !&#x3D;&#x3D; undefined)&#123;    arr.splice(i,1);    i--;  &#x2F;&#x2F; 解决删除元素后，数组塌陷问题    continue;  &#125;  obj[item] &#x3D; item&#125;&#x2F;&#x2F; arr: [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h3 id="2-交换元素位置从而替换吊splice方法"><a href="#2-交换元素位置从而替换吊splice方法" class="headerlink" title="2. 交换元素位置从而替换吊splice方法"></a>2. 交换元素位置从而替换吊splice方法</h3><p>当数组数据比较庞大时，由于splice实现删除的性能不太好，会影响整个性能。交换元素的位置效率会更高一点。</p></blockquote><p>若当前元素重复，则与数组最后一位元素交换位置，i–再次进行判断，同时length–，</p><pre class="line-numbers language-none"><code class="language-none">let obj &#x3D; &#123;&#125;for(let i &#x3D; 0; i &lt; arr.length; i++) &#123;  let item &#x3D; arr[i]  if(obj[item] !&#x3D;&#x3D; undefined)&#123;    arr[i] &#x3D; arr[arr.length-1]  &#x2F;&#x2F;当前元素与元素数组最后一位元素交换数组    arr.length--;    i--;  &#x2F;&#x2F; 解决删除元素后，数组塌陷问题    continue;  &#125;  obj[item] &#x3D; item&#125;&#x2F;&#x2F; arr: [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h3 id="3-Array-filter-Array-indexOf"><a href="#3-Array-filter-Array-indexOf" class="headerlink" title="3. Array.filter + Array.indexOf"></a>3. Array.filter + Array.indexOf</h3><p>filter()方法：创建一个新数组，新数组中的元素是指定数组中**符合(符合既保留))**某种条件的所有元素，如果没有符合条件的元素则返回空数组。</p></blockquote><p>indexOf()方法：返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</p><p>语法：array.filter(function(item,index,arr))</p><p><strong>filter() 不会对空数组进行检测。</strong></p><p><strong>filter() 不会改变原始数组。</strong></p><p>原理：返回item第一次出现的位置等于当前的index(索引值)的元素。</p><pre class="line-numbers language-none"><code class="language-none">let newArr &#x3D; arr.filter((item, index) &#x3D;&gt; arr.indexOf(item) &#x3D;&#x3D;&#x3D; index);  &#x2F;&#x2F; [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><h3 id="4-Array-filter-Object-hasOwnProperty"><a href="#4-Array-filter-Object-hasOwnProperty" class="headerlink" title="4. Array.filter + Object.hasOwnProperty"></a>4. Array.filter + Object.hasOwnProperty</h3></blockquote><p>hasOwnProperty()方法：返回一个布尔值，表示对象自身属性中是否具有指定的属性原理，利用对象的键名不可重复的特点。（也就是，是否有指定的键）。</p><pre class="line-numbers language-none"><code class="language-none">let obj &#x3D; &#123;&#125;arr.filter(item &#x3D;&gt; obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] &#x3D; true))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><h3 id="5-Array-reduce-Array-includes"><a href="#5-Array-reduce-Array-includes" class="headerlink" title="5. Array.reduce + Array.includes"></a>5. Array.reduce + Array.includes</h3><p>reduce()方法：接收一个函数作为累加器，数组中的每个值从左到右开始计算，最终计算为一个值，</p></blockquote><p>语法：arr.reduce(function(total,currValue,currIndex,arr),initValue)</p><p><strong>reduce() 对于空数组是不会执行回调函数的。</strong><br><strong>total：必需。初始值, 或者计算结束后的返回值</strong><br><strong>currValue：必需。当前元素</strong><br><strong>currIndex：可选。当前元素的索引</strong><br><strong>arr ：可选。当前数组对象。</strong><br><strong>initValue：可选。累加器初始值</strong></p><p><em>一个空数组调用reduce方法没有提供初始值，会报错。</em><br><em>提供了初始值，将直接返回该初始值，不会调用callback函数。</em><br><em>非空数组调用reduce方法提供初始值，则total将会等于初始值，且currValue从第一个元素开始。</em><br><em>如没有提供初始值，则total会等于第一个元素值，且currValue将会从第二个元素开始。</em></p><pre class="line-numbers language-none"><code class="language-none">let newArr &#x3D; arr.reduce((accu, cur) &#x3D;&gt; &#123;    return accu.includes(cur) ? accu : accu.concat(cur);  &#x2F;&#x2F; 1. 拼接方法    &#x2F;&#x2F; return accu.includes(cur) ? accu : [...accu, cur]; &#x2F;&#x2F; 2. 扩展运算&#125;, []);&#x2F;&#x2F; [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</p><blockquote><h3 id="6-Array-indexOf"><a href="#6-Array-indexOf" class="headerlink" title="6. Array.indexOf"></a>6. Array.indexOf</h3><p>indexOf()方法：返回数组中某个指定元素的位置，该方法遍历数组，查找有无对应元素并返回元素第一次出现的索引，未找到指定元素就返回-1。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">let newArr &#x3D; []for (var i &#x3D; 0;i&lt;arr.length;i++)&#123;  if(newArr.indexOf(arr[i]) &#x3D;&#x3D;&#x3D;-1 ) newArr.push(arr[i])&#125;&#x2F;&#x2F;等同于 forEach 写法arr.forEach(item &#x3D;&gt; newArr.indexOf(item) &#x3D;&#x3D;&#x3D; -1 ? newArr.push(item) : &#39;&#39;)console.log(newArr)  &#x2F;&#x2F;[1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h3 id="7-Array-includes"><a href="#7-Array-includes" class="headerlink" title="7. Array.includes"></a>7. Array.includes</h3><p>includes() 方法：用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">let newArr &#x3D; []for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;  if (!newArr.includes(arr[i]))  newArr.push(arr[i])&#125;&#x2F;&#x2F;等同于 forEach 写法arr.forEach( item &#x3D;&gt; !newArr.includes(item) ? newArr.push(item) : &#39;&#39;)console.log(newArr)  &#x2F;&#x2F; [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h3 id="8-new-Set-扩展运算符-Array-from"><a href="#8-new-Set-扩展运算符-Array-from" class="headerlink" title="8. new Set + 扩展运算符 || Array.from"></a>8. new Set + 扩展运算符 || Array.from</h3><p>新的数据结构Set，类似于数组，但是成员的值都是唯一的，没有重复值。Set本身就是一个构造函数，可以接受一个具有 iterable 接口数据结构作为参数（如数组，字符串），用来初始化。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">let newArr &#x3D; [...new Set(arr)];      &#x2F;&#x2F; [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]let newArr &#x3D; Array.from(new Set(arr));      &#x2F;&#x2F; [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]let newStr &#x3D; [...new Set(&#39;ababbc&#39;)].join(&#39;&#39;)  &#x2F;&#x2F;  &#39;abc&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h3 id="9-new-Map"><a href="#9-new-Map" class="headerlink" title="9. new Map"></a>9. new Map</h3><p>新的数据结构Map，类似于对象也是键值对的集合。</p></blockquote><p>set方法设置键名key对应的键值为value，然后返回整个Map结构。如果key已经有值，则键值就会被更新，否则就新生成该键。get方法读取key对应的键值，如果找不到key。返回undefined。has方法返回一个布尔值，表示某个键是否在当前Map对象之中。</p><pre class="line-numbers language-none"><code class="language-none">let map &#x3D; new Map();let newStr &#x3D; [];for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;    if (!map.has(arr[i])) &#123;        map.set(arr[i], true);        newStr.push(arr[i]);    &#125;&#125;console.log(newArr)  &#x2F;&#x2F; [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>set() 方法为 Map 对象添加或更新一个指定了键（key）和值（value）的（新）键值对。</p><p>来源 | <a href="https://www.cnblogs.com/echoyya/p/14555831.html">https://www.cnblogs.com/echoyya/p/14555831.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 数组去重 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组去重 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6 笔记之第十四章 Set 和 Map 数据结构</title>
      <link href="/2021/10/27/es6-14/"/>
      <url>/2021/10/27/es6-14/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Set"><a href="#1-Set" class="headerlink" title="1. Set"></a>1. Set</h2><h2 id="1-1-基本用法"><a href="#1-1-基本用法" class="headerlink" title="1.1 基本用法"></a>1.1 基本用法</h2><p>Set数据结构本身是一个构造函数，用来生成Set数据结构，类似于数组，但内部成员具有唯一性。</p><ol><li><p>去除数组重复成员的方法：[…new Set(array)]</p></li><li><p>同样也可以用于去除字符串中的重复字符：[…new Set(‘ababbbbb’)].join(‘’)   //“abc”</p></li></ol><p>Set内部判断两值是否相等，类似于精确相等运算符(===),主要区别在于，Set内部认为NaN等与自身，精确相等认为NaN不等自身</p><p>此外，在Set内部两个对象总是不相等的，即便是两个空对象，也不相等。</p><h2 id="1-2-Set-实例的属性和方法"><a href="#1-2-Set-实例的属性和方法" class="headerlink" title="1.2 Set 实例的属性和方法"></a>1.2 Set 实例的属性和方法</h2><ol><li>Set 实例的属性</li></ol><ul><li><code>Set.prototype.constructor</code>: 构造函数，默认为<code>Set</code>函数</li><li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li></ul><ol start="2"><li>Set 实例的方法<br>分为两大类 ：操作方法（用于操作数据）和遍历方法（用于遍历成员）。</li></ol><ul><li><code>Set.prototype.add(value)</code>：添加某个值，返回 Set 结构本身。</li><li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li><li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为Set的成员。</li><li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li></ul><p>属性和方法的实例：</p><pre class="line-numbers language-none"><code class="language-none">s.add(1).add(2).add(2); &#x2F;&#x2F; 注意2被加入了两次s.size &#x2F;&#x2F; 2s.has(1) &#x2F;&#x2F; trues.has(2) &#x2F;&#x2F; trues.has(3) &#x2F;&#x2F; falses.delete(2);s.has(2) &#x2F;&#x2F; false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组去重的方法之一：</p><pre class="line-numbers language-none"><code class="language-none">function dedupe(array) &#123;  return Array.from(new Set(array));&#125;dedupe([1, 1, 2, 3]) &#x2F;&#x2F; [1, 2, 3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-遍历操作"><a href="#1-3-遍历操作" class="headerlink" title="1.3 遍历操作"></a>1.3 遍历操作</h2><h2 id="2-WeakSet"><a href="#2-WeakSet" class="headerlink" title="2. WeakSet"></a>2. WeakSet</h2><h2 id="2-1-含义"><a href="#2-1-含义" class="headerlink" title="2.1 含义"></a>2.1 含义</h2><h2 id="2-2-语法"><a href="#2-2-语法" class="headerlink" title="2.2 语法"></a>2.2 语法</h2><h2 id="3-Map"><a href="#3-Map" class="headerlink" title="3. Map"></a>3. Map</h2><h2 id="3-1-含义和基本用法"><a href="#3-1-含义和基本用法" class="headerlink" title="3.1 含义和基本用法"></a>3.1 含义和基本用法</h2><h2 id="3-2-实例的属性和操作方法"><a href="#3-2-实例的属性和操作方法" class="headerlink" title="3.2 实例的属性和操作方法"></a>3.2 实例的属性和操作方法</h2><h2 id="3-3-遍历方法"><a href="#3-3-遍历方法" class="headerlink" title="3.3 遍历方法"></a>3.3 遍历方法</h2><h2 id="3-4-与其他数据结构的互相转换"><a href="#3-4-与其他数据结构的互相转换" class="headerlink" title="3.4 与其他数据结构的互相转换"></a>3.4 与其他数据结构的互相转换</h2><h2 id="4-WeakMap"><a href="#4-WeakMap" class="headerlink" title="4. WeakMap"></a>4. WeakMap</h2><h2 id="4-1-含义"><a href="#4-1-含义" class="headerlink" title="4.1 含义"></a>4.1 含义</h2><h2 id="4-2-WeakMap-的语法"><a href="#4-2-WeakMap-的语法" class="headerlink" title="4.2 WeakMap 的语法"></a>4.2 WeakMap 的语法</h2><h2 id="4-3-WeakMap-的示例"><a href="#4-3-WeakMap-的示例" class="headerlink" title="4.3 WeakMap 的示例"></a>4.3 WeakMap 的示例</h2><h2 id="4-4-WeakMap-的用途"><a href="#4-4-WeakMap-的用途" class="headerlink" title="4.4 WeakMap 的用途"></a>4.4 WeakMap 的用途</h2><h2 id="5-WeakRef"><a href="#5-WeakRef" class="headerlink" title="5. WeakRef"></a>5. WeakRef</h2><h2 id="6-FinalizationRegistry"><a href="#6-FinalizationRegistry" class="headerlink" title="6. FinalizationRegistry"></a>6. FinalizationRegistry</h2>]]></content>
      
      
      <categories>
          
          <category> ES6 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6 笔记之第十一章 对象的新增方法</title>
      <link href="/2021/10/26/es6-11/"/>
      <url>/2021/10/26/es6-11/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Object-is"><a href="#1-Object-is" class="headerlink" title="1. Object.is()"></a>1. Object.is()</h2><ol><li>ES5 : </li></ol><ul><li>相等运算符(==) :会自动转换数据类型</li><li>严格相等运算符(===)：NaN不等于自身，+0等于-0</li></ul><ol start="2"><li>ES6 :</li></ol><ul><li><p>Object.is() : 比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p></li><li><p>不同之处只有两个：一是+0不等于-0，二是NaN等于自身。</p><pre class="line-numbers language-none"><code class="language-none">Object.is(&#123;&#125;, &#123;&#125;)&#x2F;&#x2F; false+0 &#x3D;&#x3D;&#x3D; -0 &#x2F;&#x2F;trueNaN &#x3D;&#x3D;&#x3D; NaN &#x2F;&#x2F; falseObject.is(+0, -0) &#x2F;&#x2F; falseObject.is(NaN, NaN) &#x2F;&#x2F; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="2-Object-assign"><a href="#2-Object-assign" class="headerlink" title="2. Object.assign()"></a>2. Object.assign()</h2><h3 id="2-1-基本用法"><a href="#2-1-基本用法" class="headerlink" title="2.1 基本用法"></a>2.1 基本用法</h3><p><code>Object.assign()</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。该方法的第一个参数是目标参数，其余都是源对象。<br><strong>注意</strong> 如果目标对象和源对象有一个或者多个同名属性，则后边的属性会覆盖前面的属性</p><ul><li><p>如果Object.is()方法只有一个对象参数，会直接返回该参数</p></li><li><p>如果Object.is()方法的参数不是对象，先转成对象再返回</p></li><li><p>由于undefined和null无法转为对象，如果参数是他们就会报错</p></li><li><p>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</p><blockquote><pre class="line-numbers language-none"><code class="language-none">const v1 &#x3D; &#39;abc&#39;;const v2 &#x3D; true;const v3 &#x3D; 10;const obj &#x3D; Object.assign(&#123;&#125;, v1, v2, v3);console.log(obj); &#x2F;&#x2F; &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中，v1、v2、v3分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。</p></blockquote></li><li><p>Object.assign()拷贝的属性是有限制的，只拷贝源对象的<strong>自身属性</strong>（不拷贝继承属性），也<strong>不拷贝不可枚举</strong>的属性（enumerable: false）。</p><pre class="line-numbers language-none"><code class="language-none">Object.assign(&#123;b: &#39;c&#39;&#125;,  Object.defineProperty(&#123;&#125;, &#39;invisible&#39;, &#123;    enumerable: false,    value: &#39;hello&#39;  &#125;))&#x2F;&#x2F; &#123; b: &#39;c&#39; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码中，要拷贝的对象只有不可枚举的invisible，因为不可枚举，所以没有被拷贝进去。</p></li><li><p>属性名为Symbol值得属性，也会被拷贝</p><pre class="line-numbers language-none"><code class="language-none">Object.assign(&#123; a: &#39;b&#39; &#125;, &#123; [Symbol(&#39;c&#39;)]: &#39;d&#39; &#125;)&#x2F;&#x2F; &#123; a: &#39;b&#39;, Symbol(c): &#39;d&#39; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-2-注意点"><a href="#2-2-注意点" class="headerlink" title="2.2 注意点"></a>2.2 注意点</h3><h4 id="1-浅拷贝"><a href="#1-浅拷贝" class="headerlink" title="(1)浅拷贝"></a>(1)浅拷贝</h4><p><code>Object.assign()</code>方法实行的是浅拷贝，而不是深拷贝。(浅拷贝仅是对对象的引用，会随之改变而改变)</p></li></ul><h4 id="2-同名属性的替换"><a href="#2-同名属性的替换" class="headerlink" title="(2)同名属性的替换"></a>(2)同名属性的替换</h4><p>对于嵌套的对象，遇到同名属性时，处理方法时替换而不是添加。</p><pre class="line-numbers language-none"><code class="language-none">const target &#x3D; &#123; a: &#123; b: &#39;c&#39;, d: &#39;e&#39; &#125; &#125;const source &#x3D; &#123; a: &#123; b: &#39;hello&#39; &#125; &#125;Object.assign(target, source)&#x2F;&#x2F; &#123; a: &#123; b: &#39;hello&#39; &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>而不会得到<code>&#123; a: &#123; b: &#39;hello&#39;, d: &#39;e&#39; &#125; &#125;</code>的结果。</p><h4 id="3-数组的处理"><a href="#3-数组的处理" class="headerlink" title="(3)数组的处理"></a>(3)数组的处理</h4><p><code>Object.assign()</code>可以处理数组，但是会把数组视为对象</p><pre class="line-numbers language-none"><code class="language-none">Object.assign([1, 2, 3], [4, 5])&#x2F;&#x2F; [4, 5, 3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-取值函数的处理"><a href="#4-取值函数的处理" class="headerlink" title="(4)取值函数的处理"></a>(4)取值函数的处理</h4><p><code>Object.assign()</code>只能进行值的复制，如果复制的值是一个取值函数，那么将会去之后在进行复制。</p><pre class="line-numbers language-none"><code class="language-none">const source &#x3D; &#123;  get foo() &#123; return 1 &#125;&#125;;const target &#x3D; &#123;&#125;;Object.assign(target, source)&#x2F;&#x2F; &#123; foo: 1 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-常见用途"><a href="#2-3-常见用途" class="headerlink" title="2.3 常见用途"></a>2.3 常见用途</h3><h4 id="1-为对象添加属性"><a href="#1-为对象添加属性" class="headerlink" title="(1)为对象添加属性"></a>(1)为对象添加属性</h4><h4 id="2-为对象添加方法"><a href="#2-为对象添加方法" class="headerlink" title="(2)为对象添加方法"></a>(2)为对象添加方法</h4><h4 id="3-克隆对象"><a href="#3-克隆对象" class="headerlink" title="(3)克隆对象"></a>(3)克隆对象</h4><pre class="line-numbers language-none"><code class="language-none">function clone(origin) &#123;  return Object.assign(&#123;&#125;, origin);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>将原始对象拷贝到一个空对象，就得到了原始对象的克隆。</p><p>上述方法，只能克隆原始对象自身的值，不能克隆他继承的值。保持继承链，可以采用下述方法</p><pre class="line-numbers language-none"><code class="language-none">function clone(origin) &#123;  let originProto &#x3D; Object.getPrototypeOf(origin);  return Object.assign(Object.create(originProto), origin);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-合并多个对象"><a href="#4-合并多个对象" class="headerlink" title="(4)合并多个对象"></a>(4)合并多个对象</h4><ul><li>将多个对象合并到某个对象<pre class="line-numbers language-none"><code class="language-none">const merge &#x3D;  (target, ...sources) &#x3D;&gt; Object.assign(target, ...sources);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>希望合并后返回一个新对象<pre class="line-numbers language-none"><code class="language-none">const merge &#x3D;  (...sources) &#x3D;&gt; Object.assign(&#123;&#125;, ...sources);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h4 id="5-为属性指定默认值"><a href="#5-为属性指定默认值" class="headerlink" title="(5)为属性指定默认值"></a>(5)为属性指定默认值</h4><h2 id="3-Object-getOwnPropertyDescriptors"><a href="#3-Object-getOwnPropertyDescriptors" class="headerlink" title="3. Object.getOwnPropertyDescriptors()"></a>3. Object.getOwnPropertyDescriptors()</h2><p>ES5中的<code>Object.getOwnPropertyDescriptor()</code>方法会返回某个对象属性的描述对象。</p><p>ES2017 引入了<code>Object.getOwnPropertyDescriptors()</code>方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p><pre class="line-numbers language-none"><code class="language-none">const obj &#x3D; &#123;  foo: 123,  get bar() &#123; return &#39;abc&#39; &#125;&#125;;Object.getOwnPropertyDescriptors(obj)&#x2F;&#x2F; &#123; foo:&#x2F;&#x2F;    &#123; value: 123,&#x2F;&#x2F;      writable: true,&#x2F;&#x2F;      enumerable: true,&#x2F;&#x2F;      configurable: true &#125;,&#x2F;&#x2F;   bar:&#x2F;&#x2F;    &#123; get: [Function: get bar],&#x2F;&#x2F;      set: undefined,&#x2F;&#x2F;      enumerable: true,&#x2F;&#x2F;      configurable: true &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该方法的引入目的，主要是为了解决 <code>Object.assign()</code>无法正确拷贝get属性和set属性的问题。</p><h2 id="4-proto-属性，Object-setPrototypeOf-，Object-getPrototypeOf"><a href="#4-proto-属性，Object-setPrototypeOf-，Object-getPrototypeOf" class="headerlink" title="4. __proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()"></a>4. __proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()</h2><ul><li>__proto__属性用来读取或设置当前对象的原型对象。</li><li>Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的原型对象（prototype），返回参数对象本身。</li><li>该方法与Object.setPrototypeOf方法配套，用于<strong>读取</strong>一个对象的原型对象。</li></ul><h2 id="5-Object-keys-，Object-values-，Object-entries"><a href="#5-Object-keys-，Object-values-，Object-entries" class="headerlink" title="5. Object.keys()，Object.values()，Object.entries()"></a>5. Object.keys()，Object.values()，Object.entries()</h2><h3 id="5-1-Object-keys-，"><a href="#5-1-Object-keys-，" class="headerlink" title="5.1 Object.keys()，"></a>5.1 Object.keys()，</h3><p>ES5 引入了<code>Object.keys</code>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的<strong>键名</strong>。</p><pre class="line-numbers language-none"><code class="language-none">var obj &#x3D; &#123; foo: &#39;bar&#39;, baz: 42 &#125;;Object.keys(obj)&#x2F;&#x2F; [&quot;foo&quot;, &quot;baz&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>ES2017 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for…of循环使用。</p><pre class="line-numbers language-none"><code class="language-none">let &#123;keys, values, entries&#125; &#x3D; Object;let obj &#x3D; &#123; a: 1, b: 2, c: 3 &#125;;for (let key of keys(obj)) &#123;  console.log(key); &#x2F;&#x2F; &#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;for (let value of values(obj)) &#123;  console.log(value); &#x2F;&#x2F; 1, 2, 3&#125;for (let [key, value] of entries(obj)) &#123;  console.log([key, value]); &#x2F;&#x2F; [&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-Object-values-，"><a href="#5-2-Object-values-，" class="headerlink" title="5.2 Object.values()，"></a>5.2 Object.values()，</h3><p><code>Object.values</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的<strong>键值</strong>。</p><pre class="line-numbers language-none"><code class="language-none">const obj &#x3D; &#123; 100: &#39;a&#39;, 2: &#39;b&#39;, 7: &#39;c&#39; &#125;;Object.values(obj)&#x2F;&#x2F; [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是b、c、a。</p><ol><li><code>Object.values</code>只返回对象自身的可遍历属性。<pre class="line-numbers language-none"><code class="language-none">const obj &#x3D; Object.create(&#123;&#125;, &#123;p: &#123;value: 42&#125;&#125;);Object.values(obj) &#x2F;&#x2F; []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>上面代码中，<code>Object.create</code>方法的第二个参数添加的对象属性（属性p），如果不显式声明，默认是不可遍历的，因为p的属性描述对象的<code>enumerable</code>默认是<code>false</code>，<code>Object.values</code>不会返回这个属性。</li></ol><p>  只要把<code>enumerable</code>改成<code>true</code>，<code>Object.values</code>就会返回属性p的值。<br>  <pre class="line-numbers language-none"><code class="language-none">const obj &#x3D; Object.create(&#123;&#125;, &#123;p:  &#123;    value: 42,    enumerable: true  &#125;&#125;);Object.values(obj) &#x2F;&#x2F; [42]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>2. <code>Object.values</code>会过滤属性名为 <code>Symbol</code> 值的属性。</p><pre class="line-numbers language-none"><code class="language-none">Object.values(&#123; [Symbol()]: 123, foo: &#39;abc&#39; &#125;);   &#x2F;&#x2F; [&#39;abc&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>如果<code>Object.values</code>方法的参数是一个字符串，会返回各个字符组成的一个数组。<pre class="line-numbers language-none"><code class="language-none">Object.values(&#39;foo&#39;)   &#x2F;&#x2F; [&#39;f&#39;, &#39;o&#39;, &#39;o&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="5-3-Object-entries"><a href="#5-3-Object-entries" class="headerlink" title="5.3 Object.entries()"></a>5.3 Object.entries()</h3><p><code>Object.entries()</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p><pre class="line-numbers language-none"><code class="language-none">const obj &#x3D; &#123; foo: &#39;bar&#39;, baz: 42 &#125;;Object.entries(obj)&#x2F;&#x2F; [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>属性名是一个 Symbol 值，该属性会被忽略<pre class="line-numbers language-none"><code class="language-none">Object.entries(&#123; [Symbol()]: 123, foo: &#39;abc&#39; &#125;);&#x2F;&#x2F; [ [ &#39;foo&#39;, &#39;abc&#39; ] ]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><code>Object.entries</code>的基本用途是遍历对象的属性。<pre class="line-numbers language-none"><code class="language-none">let obj &#x3D; &#123; one: 1, two: 2 &#125;;for (let [k, v] of Object.entries(obj)) &#123;  console.log(    &#96;$&#123;JSON.stringify(k)&#125;: $&#123;JSON.stringify(v)&#125;&#96;  );&#125;&#x2F;&#x2F; &quot;one&quot;: 1&#x2F;&#x2F; &quot;two&quot;: 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><code>Object.entries</code>方法的另一个用处是，将对象转为真正的<code>Map</code>结构。<pre class="line-numbers language-none"><code class="language-none">const obj &#x3D; &#123; foo: &#39;bar&#39;, baz: 42 &#125;;const map &#x3D; new Map(Object.entries(obj));map &#x2F;&#x2F; Map &#123; foo: &quot;bar&quot;, baz: 42 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="6-Object-fromEntries"><a href="#6-Object-fromEntries" class="headerlink" title="6. Object.fromEntries()"></a>6. Object.fromEntries()</h2><code>Object.fromEntries()</code>方法是<code>Object.entries()</code>的逆操作，用于将一个键值对数组转为对象。<pre class="line-numbers language-none"><code class="language-none">Object.fromEntries([  [&#39;foo&#39;, &#39;bar&#39;],  [&#39;baz&#39;, 42]])&#x2F;&#x2F; &#123; foo: &quot;bar&quot;, baz: 42 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象。<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 例一const entries &#x3D; new Map([  [&#39;foo&#39;, &#39;bar&#39;],  [&#39;baz&#39;, 42]]);Object.fromEntries(entries)&#x2F;&#x2F; &#123; foo: &quot;bar&quot;, baz: 42 &#125;&#x2F;&#x2F; 例二const map &#x3D; new Map().set(&#39;foo&#39;, true).set(&#39;bar&#39;, false);Object.fromEntries(map)&#x2F;&#x2F; &#123; foo: true, bar: false &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>该方法的一个用处是配合<code>URLSearchParams</code>对象，将<strong>查询字符串</strong>转为对象。<pre class="line-numbers language-none"><code class="language-none">Object.fromEntries(new URLSearchParams(&#39;foo&#x3D;bar&amp;baz&#x3D;qux&#39;))&#x2F;&#x2F; &#123; foo: &quot;bar&quot;, baz: &quot;qux&quot; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> ES6 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6 笔记之第十二章 运算符的扩展</title>
      <link href="/2021/10/25/es6-12/"/>
      <url>/2021/10/25/es6-12/</url>
      
        <content type="html"><![CDATA[<h2 id="1-指数运算符"><a href="#1-指数运算符" class="headerlink" title="1. 指数运算符( ** )"></a>1. 指数运算符( ** )</h2><ol><li> <strong>注意</strong> 运算符的特点是右结合，而不是左结合。多个运算符连用时，从最右边开始计算。<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 相当于 2 ** (3 ** 2)2 ** 3 ** 2    &#x2F;&#x2F; 512<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>指数运算符可以与等号结合，形成一个新的赋值运算符（ **= ）<pre class="line-numbers language-none"><code class="language-none">let a &#x3D; 1.5;a **&#x3D; 2;   &#x2F;&#x2F; 等同于 a &#x3D; a * a;let b &#x3D; 4;b **&#x3D; 3;   &#x2F;&#x2F; 等同于 b &#x3D; b * b * b;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="2-链判断运算符"><a href="#2-链判断运算符" class="headerlink" title="2. 链判断运算符 ( ?. )"></a>2. 链判断运算符 ( ?. )</h2><pre class="line-numbers language-none"><code class="language-none">const firstName &#x3D; message?.body?.user?.firstName || &#39;default&#39;;const fooValue &#x3D; myForm.querySelector(&#39;input[name&#x3D;foo]&#39;)?.value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面代码使用了<code>?.</code>运算符，直接在链式调用的时候判断，左侧的对象是否为<code>null</code>或<code>undefined</code>。如果是的，就不再往下运算，而是返回<code>undefined</code>。<br><strong>三种写法</strong></p><ul><li>obj?.prop // 对象属性是否存在</li><li>obj?.[expr] // 同上</li><li>func?.(…args) // 函数或对象方法是否存在<br>下面是?.运算符常见形式，以及不使用该运算符时的等价形式。<pre class="line-numbers language-none"><code class="language-none">a?.b&#x2F;&#x2F; 等同于a &#x3D;&#x3D; null ? undefined : a.ba?.[x]&#x2F;&#x2F; 等同于a &#x3D;&#x3D; null ? undefined : a[x]a?.b()&#x2F;&#x2F; 等同于a &#x3D;&#x3D; null ? undefined : a.b()a?.()&#x2F;&#x2F; 等同于a &#x3D;&#x3D; null ? undefined : a()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>运算符的注意点</strong></p><ul><li>短路机制</li><li>括号的影响：对圆括号外部没有影响</li><li>报错场合：构造函数、链运算符右侧有模板字符串、链运算符左侧是super关键字、链运算符用于赋值运算符左侧</li><li>链运算符右侧不得为十进制数值</li></ul><h2 id="3-Null-判断运算符"><a href="#3-Null-判断运算符" class="headerlink" title="3. Null 判断运算符 ( ?? )"></a>3. Null 判断运算符 ( ?? )</h2><p>它的行为类似||，但是只有运算符左侧的值为null或undefined时，才会返回右侧的值。</p><p>跟链判断运算符?.配合使用，为null或undefined的值设置默认值。</p><pre class="line-numbers language-none"><code class="language-none">const animationDuration &#x3D; response.settings?.animationDuration ?? 300;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面代码中，如果<code>response.settings</code>是null或undefined，或者<code>response.settings.animationDuration</code>是null或undefined，就会返回默认值300。也就是说，这一行代码包括了两级属性的判断。</p><h2 id="4-逻辑赋值运算符"><a href="#4-逻辑赋值运算符" class="headerlink" title="4. 逻辑赋值运算符"></a>4. 逻辑赋值运算符</h2><p>先进行逻辑运算，然后根据运算结果，再视情况进行赋值运算。</p><h3 id="1-或赋值运算符"><a href="#1-或赋值运算符" class="headerlink" title="1. 或赋值运算符   ( ||= )"></a>1. 或赋值运算符   ( ||= )</h3><p>x ||= y  // 等同于  x || (x = y)</p><h3 id="2-与赋值运算符-amp-amp"><a href="#2-与赋值运算符-amp-amp" class="headerlink" title="2. 与赋值运算符   ( &amp;&amp;= )"></a>2. 与赋值运算符   ( &amp;&amp;= )</h3><p>x &amp;&amp;= y  // 等同于  x &amp;&amp; (x = y)</p><h3 id="3-Null-赋值运算符"><a href="#3-Null-赋值运算符" class="headerlink" title="3. Null 赋值运算符   ( ??= )"></a>3. Null 赋值运算符   ( ??= )</h3><p>x ??= y  // 等同于  x ?? (x = y)</p><h3 id="4-用途"><a href="#4-用途" class="headerlink" title="4. 用途"></a>4. 用途</h3><p>为变量或属性设置默认值</p>]]></content>
      
      
      <categories>
          
          <category> ES6 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将dev分支代码合并到master主干</title>
      <link href="/2021/10/24/guthub/"/>
      <url>/2021/10/24/guthub/</url>
      
        <content type="html"><![CDATA[<h4 id="1-首先查看当前所在的分支-git-branch"><a href="#1-首先查看当前所在的分支-git-branch" class="headerlink" title="1. 首先查看当前所在的分支 : git branch"></a>1. 首先查看当前所在的分支 : <code>git branch</code></h4><h4 id="2-切换到-dev-分支-git-checkout-dev"><a href="#2-切换到-dev-分支-git-checkout-dev" class="headerlink" title="2. 切换到 dev 分支 :git checkout dev"></a>2. 切换到 <code>dev</code> 分支 :<code>git checkout dev</code></h4><h4 id="3-在-dev-分支下提交最新代码-git-add"><a href="#3-在-dev-分支下提交最新代码-git-add" class="headerlink" title="3. 在 dev 分支下提交最新代码 : git add ."></a>3. 在 <code>dev</code> 分支下提交最新代码 : <code>git add .</code></h4><h4 id="4-提交修改信息-git-commit-m-quot-XXXXX-quot"><a href="#4-提交修改信息-git-commit-m-quot-XXXXX-quot" class="headerlink" title="4. 提交修改信息 : git commit -m &quot;XXXXX&quot;"></a>4. 提交修改信息 : <code>git commit -m &quot;XXXXX&quot;</code></h4><h4 id="5-将新代码内容推送到远程仓库-git-push-origin-dev"><a href="#5-将新代码内容推送到远程仓库-git-push-origin-dev" class="headerlink" title="5. 将新代码内容推送到远程仓库 : git push origin dev"></a>5. 将新代码内容推送到远程仓库 : <code>git push origin dev</code></h4><h4 id="6-将新代码提交到master主干上，需要先切换到master主干-git-checkout-master"><a href="#6-将新代码提交到master主干上，需要先切换到master主干-git-checkout-master" class="headerlink" title="6. 将新代码提交到master主干上，需要先切换到master主干 : git checkout master"></a>6. 将新代码提交到<code>master</code>主干上，需要先切换到<code>master</code>主干 : <code>git checkout master</code></h4><h4 id="7-拉取master主干全部代码-git-pull"><a href="#7-拉取master主干全部代码-git-pull" class="headerlink" title="7. 拉取master主干全部代码 : git pull"></a>7. 拉取<code>master</code>主干全部代码 : <code>git pull</code></h4><h4 id="8-把dev的新代码合并到master主干上-git-merge-dev"><a href="#8-把dev的新代码合并到master主干上-git-merge-dev" class="headerlink" title="8. 把dev的新代码合并到master主干上 : git merge dev#"></a>8. 把<code>dev</code>的新代码合并到<code>master</code>主干上 : <code>git merge dev#</code></h4><h4 id="9-把代码推送到远程仓库-git-push-origin-master"><a href="#9-把代码推送到远程仓库-git-push-origin-master" class="headerlink" title="9. 把代码推送到远程仓库 : git push origin master"></a>9. 把代码推送到远程仓库 : <code>git push origin master</code></h4>]]></content>
      
      
      <categories>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目常见方法合集(笔记篇)</title>
      <link href="/2021/10/22/function/"/>
      <url>/2021/10/22/function/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 密码错误." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="a5ef69d19a894ed4f56dcac4c76be59e24acce76921c2036aba74eaeef4b7aff">10d79030e8222445804370796b90fca169b2796a276913b7c1ca4281f96701e0a4365debdc32922f87e7cf8103c62cf2e386a3d679d2695d3e2bcfcc55a401755244f8d172c5a8badd67089adbc49820a404edbd8252714da834a77f5002487fad66a2a8ee36efb56f2024924090999de65a96c9bf9a53e043eebeb7b23a497ac205cb19023138e4419cb89be262704cc29c550acc23f642941725fb8357a4968aaba138e48fde12193131c0c329e1b5078982e9f12f74374ac8304325b43c245363e6521b52f778fb89a2d04a6885f6ae34172c3f0585cfbbede3764fec47bf8f2945a54a59e6b8053418c63fdc5cafc02ea92d89a203a02441a5a9c5432945a15b9e3d49fae95e81cc1005ff407f787f37c377c5f0978377e298f1b23df8d3983ce361a93f1a699785bfba32f955914a6c67cd91083c4510e219ebe43579d3860f6a734384bc7cd049162eebb0381bb2498c8512f859a2c0ed9e31de1440386ec221c3fad502623493c0d581572f45801473f4c914a5f5eb6d24a03b0da48f1b27eddab637d080f5ac6166c0107a6b8a49cf5ae545141922100d6f3321238b5fd9edfbef561545bad0c8e3ab1dd617836116ea6ecc67956bbc9ed6a2ae1024e8c24b99d9c70d6a3b2654e32ef5b0e54327f89ab142bc45adf2151b1cb4a7900eade4661ebd5e9b28827bd18c45dc3b6c4ce086c3f641e22bff83de749eeae305c2404cd9c304c05272b5348590674b98237b073318040a0e5c454a73c0e095f591f71bc9a2899ba3bcd94ad1f2ee57d54dd125da2fc8d0438426cd4e6c389a2e4ae0dd7b898672432527ff516cd5352902967413a90ae04053695b010bc0e13a3dc36266a30e76ce60e5e781a44c734bf066604dfaec86cae2685d15d9ba7375967e00548ffcecd8af5a5f0c7ec1913ec471b0cd39563d445f3a15e943f329aabdeaffbacadb26ef605985b034c679bf9d2bd27652a1fd8e11c795f8249a930dc23e82163b329a30c53dc36175d26d07d064756adc3936b4596daf5155e51866eebc223c43a8d2da855564203cc33cb3ef4aacd2017274f7add13a0b51ddfe8edd341da5a5cdcdcf1ec2e61d40d94517085c0063c0a2c1cbdfb9b13d4ee87a5d1f054587aafc857da09ea8510bbd2397cd503088a984824b2930c50fcd9be4c70a6420b52cfa7bc55a22caff05f394a52326c44e0a1a386526df5b62b9a03a0ebd42e3a72b55fa28dd5dca225ddddef50303386a757240431b5d6dc29d4799d6f7f948ea11ae01d28c84d972df59ed1f22ad26dbc5c6142078a7ae10d6ab8163fa628407131542a6e6fbc8abd7599e88ca5760d5cbd138cb8ed4a850470327738c32f37d12bebf9e181a34b96f8122efd962fdad4ee78fb274fc49607ee6fe301a278dfb90966a48b074e4a3c851e783255a0382c1d2ef762079d65bddfba658293075ff1e3d95369835f13b08eae997207a91d78dda1401ed1204578b850ed78f56c10cdcb9a26a26ff3536563ba6defdf4608a9f9d0351f6b863ed91aece8323a8c433676cd365a297f8b8a17b47c7a9bf44e94b58c987a81b36935f19a6b13b019fc51483f4258bec86203a71d0edea3e2ca46277ae4d70b33560c0dbde9e75344accd41a7bdc3a45d068d58f81791fd7c495c04c45255b19989d2433dc8512a0d8c1a95f1eb02276479ecbfc139543e782cf9b9a1b5420949e419ab5216f45d7af1d49cb8e6d3082c7713c83a989122558175d1c572aafb0b513d101e2391f6dbc8dbc9a46a7af6dfd08c589f50dd1b6426318da924a3169076e7d9e83a4356e45276928ca5b29c9c5b3d67104fb9fba831f3c2f9abc0884c54a121710b96b0a6039d71a43fda54d45dd3b121ec3e6f69f07b4c971129a0a85d4713b135fe865032e4f1e4fe04c554c9730cc740e0b359a9b6d0c077b1717b93d024bc4422bfffbe1c4d545ed87f1ccf785846a8e1bf38803719df0b74f3df7a41d7e787d4fb7a733975a22b9397c08e8602212c0097a69fa6f55203fdde085217429740d25c358d2d00c90654139e2ec80a93dc30ac8a62ff981bb48b52e8897fa3af983fa663ce7e9404131dd9487ea6b6171dfa473254649d40cde7b28e8653d0c265d72370cdb0d0aab074f2274cd3deff6694fc349b719215518652fbccb768b612ed2f16f4f2b26cfd68e6575ea78ae2670662e70caeab8c9e3528fd59110393ad98a75ece17035007881566d5eb1fc8e78cab49f0c67551132f73ba2438122a9a9c844199d950c63faa0d14a1bcffc0b7532832da301cd1ddb9d11cfa25d7cd2d4b60a9e01b9b62d4e234b5c6376813ef496e7a8a20ea8590cab891bbf185695288e01e9a224be7de05aade957c69709dadd5cadcb4d29179fcfa2c2cb65f97e6d71f15f186e1bd7fb5581e23f11dafceecf4ec4d3c5bb7977688a48d855270aca31ce33c23a7997fccbf057c5dfbd0203f6b4197a4b568b18b4dc823780498e76e18d0cf2fbc18f1707287dcd3e954577e8610a867464bf4299f20ace2021318de303664c33cd8c048ef4e004c4e4fcee17f03978c1149556a09d7336f0ed4c76483a510a2fc1282483020e85c3a5ac7dcc4c43eb403184af7d161ee30ea50e842e139594684a87a178fa5ac415dd6e621c88c1a8fa40748391ee352698a6c9876817f177f7b37c038d5748d374c43543366777ae40cb5bb594ff0c0e3b9631aa8e2b401b2ae3c4bacfb2f52fd3340676d49343c1c370b970b002346626a4676e94a03cec9532ef34754b2e622a3fe98a11172e6907087d4e50d018b942b4c1c5c95d33250b2c3eb4b53372d08bf649e9435fc84179956f327f9e6d89bca574888778dc00508d805ca3042fee16ae669a53f1e20f56ca0e116949794e290d821481f565c3efca3413161ada7905e7c1f2f5ba6edcaf9c42358aa2451ddfc0c0b06c78f8cf6cc09b8b7b6d4f91bfcf6e2ca769470591f2edae41d91c137c1cafded4c69376306d2a4805f15d5606e155e858a8b4552d15c86e91d9f936509dd8042ac99254f82b100f14faddcc4fb75c9676873adc30b65d7e462ede54b8d4ffb5c73a8da602a8392296db5b9a0dd34419f26670c8be3a28d37f0ffce900a0f47aa67fc4927717a83bf7b8cb390beb5cf180d727d69d106e00defe34ad525c44ad609675bd53b08674c0b4ed00c255f0ad1ec37a556a6577f7e30f08bfdefc2548364a20f7f9b0102833d63643503534eeb0a2a791420326c26f9a9ce74a78b60e3873297adce033bf7cb3b2fac5054ef21e61bc6c160783104e3380959488035f9eb0abcde606fbeb5450ca7997b10372d305ef53bc766934f6d770660858671cabe46b8a3b45e44fc4f0a902aadc8237afd926dad0aad4db3e456856bc58802c7bb2df3586e429d53c6cb20d6664b777ab50cc2f84a2cbd4f6306002eac170e91c7f3245c0129fdebad296de3f534793a2bf45cda06175c2f98a57a4dcec88c0074ed9df61d5d99264386d8a69746b539283c0c7bb0547c6e80d807b6c29b6d32d15782b498dddfd1163161c0a906f2783b9c5fba9101ed649c32600dc8a60eede2caec6be6f56f5e10ead69563a848187566a4b6c314dd373ace82fd3ff0115f61ba7841acf016dea042d86831dffcff4448343967c3006962f5015df4c925a387bf73782f66956edb04239884bdd22edd8b7c67ea2c164d20c39dcc3ea97d8981a89b7f0e7149d4f459ef51bc183929ffe0be66e198bad0fc3e4c3ed1a9cd843462e6aefdd34784a9a9f154b97aef2c8bb716604bf47a42ce3adc357ea02c89cb601ca56e87631eebfc7d67cdc1dcf56e1f786ca4f65dd9db4b4b16e3e2aea550c3d474d092ab27672133742fdee66b195808ee3d648fc7c665a7f64fd47d6f4016d073a6d6835789995eb32a4aca0b44cc74ef8643c028196eceed1a28a7d9b6d30e5d9ecdbef02647e2cf687715b56fca95df8e34f8cd1c2c9f790dacac41d6cfb1851edd7c3e542029614ad9d44d2f9b81accf87ab73368f0a58a66d59640f0b6d108a9c6b593e793996ad9d5a4119cba7b908356b9e1b29595f2b18ad9f6da3ceb31f0f83e60837f3e08c657b5ff5db2a2dc2d2628d668f2aaee34ca023bbcd71cddffb58d6c3d100d7f620983daaf63ebbfbb808a26840da3aa528b992140ee4a0d02710a0b7a99902d117d3d73b0c79695d339745ee8c0c7e167e612463478b467f77282e69acda57a633f602e4b5a140dbc5e58713e6d5bac1df2c3a5c9dc64f49540be219f9359e4b3e6e5d616af55cc6496247ecccbea4f06fea29f3f48961364e405b80846f3773e296705e5154b42ef68a0ef3f0dc4ff8ef764dd33982260e2b44bfa11dc26ea63a09d4318cb9c00741f5a8d18eb81b75b68537f8094d2202e50b57b0d86b4d4f0ff75db7f30afb6c1a40013abb1096e581f6ccbf1fded0da7c7ae79dadfb2fe980ca271af50d26abf68aa54269f59229dd8240524eaa57ee12e9bc053e04804fc4442a913a3b223d26ef51a520aab573e6e7567cd0f63d0337be6d8b99fe4609a77fd2979c2135a178ff87dca4ac71db2d70adab5e47a374d04c740ed7c635684a532d1ce935a8b754ef62e2dc807512def47a9b2aa158fe5176f45836d4082e4e2f93a421c48dcc83715a19581c249b3a4552e0dcdd5c00117e174ee8b2ef86004264c444c67d9c760c44ce9d0a97e359c459992a472a4577bb275d606b29328b2650689934cb178d19029d6089e9076a2e4b071b1fd7db9f45ef3241922851cb9480a9cdb42a556ef1f3b03a1461bf39056c6cfe6aad02768c44b74fac8658928f669ccf7c7306d007c5b7d297799d10d744925dbd8f27a77cb7aa10876a801644a90010d98d10c996669faa054653855bbf15f1e9996ca0e16ed4e3e526a61318c93bf205e2d910395dfe078f0c03e66e13c9628da480825f27b140fe1f2b73a117363690e536eb90ff6cd0b6b846e28426e701003a413175f35f952d84321c1ae6b6239c57013772ea1aadb91103501e97674cc289342a1fb39c05ec9b25c2d2043a70c90ab190da2c81aecb270af5b2be4b8d352f2016c2a0feea21ece40a12d82fa518f7b4f149fadfcbd9edac43afd79a7ac7b60bed8ca71dd65f7c84b5d3acb117611601db5356cdc4696e7490d4c81ac32d0749c536bee84b1d67cdac55d90377ff18a83a233ef524367f7a6f0f99c0a02553aa1da609d17d1fcca7586ed73f003e27767c2fad238a4d22370261ba0daf4e86ab81ffeca1faa42a71d9ddd1426de6f755e0da8b0057306dcb3068c795bd41fb86625456717ecfb1fad1e13b2f17d395b3cee90797d8626f9421119d6dbc6069264863150414aea1b75b0f120b59454b0c4a3a5c97ff1529a4060ec8a6d825ea074091962ed472914777ad86e7741e75822262fb4cb70fdcb96d2014d355f274c325d44adb36a619c9bea2b2245958c156f6c8eba155475cd230245781ab416e1ec67d399c2a64546d878e2f813c82d48bfe48a769c250a616ed1ce6565e335ed162222fd57b34810b1abe7e6499eebdf95aea45a06718a8e31c8954bd7f57bd7ad116e185354a86dd75f87fbdede1ee5637dde592948b48c0db02857edf12e55257d17092832bde3c73ea8dccd4e1f3bafe6e8d9f01b7f9efb33d3f5c92aae2489cbee6c9f85369f68fdac605bb147bbd7046035aaeb6e2ecf8c8459aea21d7ab32a6b417ef0b206aebb85ef5e14812870d9e43f078cd44aa7b52921cea39d5d93e61590b46b6ccd6bbf2f9a66ceade8db075cc648e3f61af5f1b050e803c2539f9451169d93e88067d6a4dd9fd4d243b7210f7a38f09790c95ac0118a913c52a9bf32a52b73768365c55b074afe8a22d5f478cc02622862a89a7fea421dad01784481d331168280fafdfc9390f4548f5f8bd2f1ceaf9badfbef3ab10ae575f4ec21558c22b58cd022dee78372834b0fb4b130a14e3563f1b025fb18c86fa08fabc1b5ebec198a70c70020ed91134ef99d8dd8060f3aa7ddbd8c3aed9c4a22958a2cb6dc29a7f0bd39a8cb8e4a276a9fc9f8d3fbcd28c424f8e1c475c5add641966fb70d1fad6c7330ab04f5577e54165a60d347c5e3a17e6de47267998dd2a86cd7e80e4b32548f3c72cafed06e3dddae06b8351d2344bfd2717ced3216d2d1acb78e3d421a5ea5bed2cf7c9106b6111da046bba9d2d66483b99cce93bd8a69204cf3eba8f259a2a62c54b822026de474793e100bbef5b2f43c99448029903b68e124bec03453b8f2357089b8adcbd4c96619b15ebfb618dd5f08caad644e61a77046713ff8153508fd4d3cffb80abc9c9a264c493e351fd378364a5edea996ebb6d083d8eb567175f6d71881a9f9895f4c69cf7b4d1be260f8f6758f466fbcd3dbe2ffb7ffae59576966756544b707bca19c6bfdd3c36f3d566accfb43dcd914a3298cbe424489ec13c6d28c4956c8344fc878c836e3da8b92889e56a4ab7c6d7a81a47c3535d968a995e0c6db9b436de1822f9fd75632649f54514e01bd3d934740185649b201ea95fbea24f48e9657e3a4d4e1a2220b131ec50005795ee8bb1c19b5982c363a045fa54882182bd9c1b4d1b587dfe494a38f0aff75279ba0a84594af512b05ae85098bb50bd4c4e80ad1d641d8f08384675d94a76b4323d1817b44f9c0e92c55428f01f1f9bdc0fbc634a895bd83f28682f9f12e9f2352c91a3057ec3f31e89e4d2ccea04e1157f5671d113727582567a9a45ed01a2ceb4e524774da1995d327fe8445b423a861765d5f8c31eafc3bbd27103edd77877c7face35e1419fd49e7b64d14c9086755d055d476e49442d6b0edb085bfb65b66a2ff17ce2896a75f5a23482dfa24ed554398dae249a955867477e1333908601874518e0d516896fc166f1936b3c10dab7daca6832714d0497036c5889858ef5e0fde67ddde3d2bec1ddee2c989eaee287556a4f845311137eec842666f7327512361505e2a2f03d2b9bf91fe418dbc33bf0b6a2bc10ef2057c29315414bdba1e7f83c8b2d37afe03a7feb380097277983104281b14bfb0b964a87eb04f4d2bf8eca97a025cbd38116cd13d13ae2d48b6cbaf241d7fe7902b78e16469b69f5d9d8c869de9b72eeb10c144433f2ab1694dda67eb42560a77b865a01645a26e93e52249394d2dcd003d0e4e57c9067a724995213d66355d45874668226e6110db04c1e2c60fa67164f8ea2a83c25821dd8696e3416a84cc811638221141f88cf461d4428ac3d38e7132c5354f77fe4f1bd918a3392745f32309c8ae573ae28f578a57b2136a2d24b5111887f56013bf0167a9e7afd384c897214870a133e5a392645e5c7af0b65a6b3d088b6b62a5f9887e5d69c1efe4fb6ce85f26cea0857ec62da0090db525b394048458e649d430c76a1b4113af0431c31c272e48843bd04756217dff14692fb868e2a6a8086063d545e91e4af98dc67f3e84f29905196275d1456048821e38002d687c617fe2b34fdbc8ff3fe02e644e3ea4c23027bcf48132acb325e196c7b4ce6d1e566d50e8a77ec4b2eceef406195d87b8ef4cc79e112dc0d8908583c84a48cd811fb365900d7d1a2ac81894fbec34cb334eda77a853bc795dc7a9e732a31d4df2a09d3dc5b0035a01a1f0db289f7928754bc6ddbe2c9ceb0797dd4f300be7cd2feaa6a1605176c49b5df287d3fb840f8e046ce68ebcce71cd0979874f3f9e459061a7f1895e827ef4cfaf06b290361a90012a929a59206c9a02460b55e41972cfb408a24c3e7914a0e3e64253e02ae59f93908a10c1d7595a1802c2d112efd9421b6edfd31c28520b60902f15fa7282787e70abf8e82d7cc991a00d66f2f48667d972ae37d79e6430e63e42c45ef6e2f81a87fbc94194ae13000ad76a5e121d7a77042f2a8c2b21f1367819e6153e0e324e811cdafccfb2a7a8765a344a3a6ed1ad860562c6fdeb4f6cf63ae42d1d56aca74e01d3e36430e89efbc81d913817af3962e402686641699dcbf1fe5530b88203ba4c96d7ef8897dce7422fd87b56eb4e625f7f6de8de2ca3ee2a4fb9753f4deacb96409f58e9ca163e4c49e5e1a193f1f35fcac5fa5ea3e28eea17bda1beff762d98b5967053251b64836623b1977ed32899f3512c4154b25b7ec354e77d03cd7bfad1aa9f15de8ebac2e73b8276f53b57c91e3b3efe67354329ac8b4a27440df7154872c60542bc53196b50191e3e49b59bf62770314482022dedfd7bd7f2a725517293dc73c8b9153f5ecd39910dbdbc333cad5bad8d9d36064c4bc102a4d896c22031233bf2aeb9fdb5b3f6bb7926e929e59cc31644e6018c1fcabc47298b1c96ac1081ce98fb53da13e40a2a4c073d69568669bd6812c4f85c44e14ebd84fff484201c41bf58579aa0de53f36eaac1c5222137253f3a94310c5891f7a53e66cc7802d64a5a5e25d388ec76821adf9045d556ae6bfb7abb5b3c5e8d193a133642fa90de5fec5c57551f02d86bfdaa7d5346662a49d6ea7886a58f2bf309011ccd89909c6ba7cdba3afacf3159029f9cb0e071cda59af1e740168df73db4979346eebbc47a810e1a114417c6d7299ba02d156b51bd2437f7f16c2376d6208597c8e113dd807c49a4424f996ea8c724d49ea9ca97160509c40671f3888db5b24ec18818043544233bc6a58d2db6965463b76cf267518306a26a6306521ac2274f1100b4a37507351eb110d3cb93414a37ec113b23eba1c19d45c5589c30b65076167000b82ae3d25e8526d7cf54040848299e561a924d7ab364ed1adda2484fe9e2a73b0c4d021399de389d0fdf243e9fd9ee36a9d51349b3bd70942e939cdca472abb1301377a9099fd2310b33cd3d3f59222274a8c5906599e8f28eb4307d0314bc97efb74bc695f76c13495b675ff52ceac2cf850a2e59cb28ad597d9233f98c25c2c0d592ff2a868b4cfa3f04a84e5d1154a01441095401023bfa4f6b67947ee9634460ef871b5f99d8cd3916db2d112be3eb41c3bfe02d967bbfa8f6c85ef4be18b5412b188a0f5b73f4f039ffe668799411fe9026e31c424ef8c0852956de13ae5c966473e99b59052be9fef5c23a86f4e010ed4e86e95b1ec83ef7be99db96fb204edbec466e7feeef48bc885a69c58e2a9daa53873e47e141ddacaac260ded56c5d5999b4acc2144cd50ada5d1c01bd5b7bd416245acbf1600a647c0510f503fc14858100c96b389c798694cf74178628cc0f45bfc80d6f45294632154fc5d1b64dff6253f12616ab9587a7320639b49361d4d746fb5a6822657840107bb919f59d3fb21675b3f501dc27c7285af6e6683688319750787f9f223efbd6ba42b17922420d91531799bdf49ac9c70c0f611afe3244ff1927562b1ff67f3ca02f4f64dca9413adb86c9e5e6fbb18e49b8005c9555b23914f3c34c039264c5276f7e2f9c953d5e95f5681d2a47afae82859c60f9c83687ed4a7dfdb2e25d9da2f6ca7e50397104d71cf7945f424542c61eb15b7a7ce4ca80ee88d07f088c722e739a02d7d88c906923d0a5fbd4f80237023c6d21a227505d28d818e82a7497675b8673a08aae8e3d6f698a58323eb5f6c4a6b62fe1105d182f8f32fd3b2e71a318439a73aa592d540fe76fac827a1f71f335fb976a534db384e96fe5ff5ff9f485eb1e96d7f8fd5a9974a60c63d98daff443148b05d79f6f165f8c4e6462ab3af982865affa238185578e601e87cd30e1f3f311a539073f4d889e84ea67b3729b3d6cc408aa0b5cdcbbe079342e23be44afb3991f949bbd61f6076402952</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-blink">      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="文章以加密--输入密码查看相关文章内容.">文章以加密--输入密码查看相关文章内容.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 方法实例 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 项目方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客插件之hexo-prism-plugin(代码高亮)</title>
      <link href="/2021/10/21/hexo-prism-plugin/"/>
      <url>/2021/10/21/hexo-prism-plugin/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>由于 <code>Hexo</code> 自带的代码高亮主题显示不好看，所以主题中使用到了 <code>hexo-prism-plugin</code> 的 <code>Hexo</code> 插件来做代码高亮，安装命令如下：</p><pre class="line-numbers language-none"><code class="language-none">npm i -S hexo-prism-plugin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-用法"><a href="#2-用法" class="headerlink" title="2. 用法"></a>2. 用法</h2><p>然后，修改 <code>Hexo</code> 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置，主要配置如下：</p><pre class="line-numbers language-none"><code class="language-none">highlight:  enable: false        &#x2F;&#x2F;确保禁用默认代码高亮插件prism_plugin:  mode: &#39;preprocess&#39;    &#x2F;&#x2F; realtime&#x2F;preprocess  theme: &#39;tomorrow&#39;  line_number: false    &#x2F;&#x2F; default false  custom_css:             &#x2F;&#x2F;optional<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-运行"><a href="#3-运行" class="headerlink" title="3. 运行"></a>3. 运行</h2><p>修改完成之后运行以下命令清理并重新生成项目：</p><pre class="line-numbers language-none"><code class="language-none">hexo clean  #清除缓存hexo generate  &#x2F;&#x2F;可简写为  hexo g  生成静态网页hexo server  #启动本地服务器，用于预览主题。hexo deploy  #可简写为 hexo d  自动生成网站静态文件，并将本地数据部署到设定的仓库(如github)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-选项"><a href="#4-选项" class="headerlink" title="4. 选项"></a>4. 选项</h2><ol><li>mode</li></ol><ul><li>realtime (Parse code on browser in real time)</li><li>preprocess (Preprocess code in node)</li></ul><ol start="2"><li>theme</li></ol><ul><li>coy</li><li>default</li><li>dark</li><li>funky</li><li>okaidia</li><li>solarizedlight</li><li>tomorrow</li><li>twilight</li><li>atom-dark</li><li>base16-ateliersulphurpool.light</li><li>cb</li><li>duotone-dark</li><li>duotone-earth</li><li>duotone-forest</li><li>duotone-light</li><li>duotone-sea</li><li>duotone-space</li><li>ghcolors</li><li>hopscotch</li><li>pojoaque</li><li>vs</li><li>xonokai</li></ul><ol start="3"><li>line_number</li></ol><ul><li>true (Show line numbers)</li><li>false (Default, Hide line numbers)</li></ul><ol start="4"><li>no_assets</li></ol><ul><li>true (Stop loading asset files)</li><li>false (Default, load script and stylesheets files)</li></ul><h2 id="5-问题"><a href="#5-问题" class="headerlink" title="5. 问题"></a>5. 问题</h2><p>该插件目前还存在一定的问题，很多使用者反应无法实现其<code>theme</code> 和 <code>line_number</code>效果 ，同样，我也遇到了这个问题，我的问题是，无法改变<code>theme</code>效果 无论改成什么主题，都是展示<code>dark</code>效果，<code>line_number</code>更是没有出现过.</p><p>这个问题还有待商榷……目前先使用hexo自带的代码高亮(个人感觉很丑)</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo-prism-plugin </tag>
            
            <tag> hexo-prism </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS Code 实用快捷键---多行编辑</title>
      <link href="/2021/10/21/vs-code/"/>
      <url>/2021/10/21/vs-code/</url>
      
        <content type="html"><![CDATA[<h2 id="多行编辑快捷键合集"><a href="#多行编辑快捷键合集" class="headerlink" title="多行编辑快捷键合集"></a>多行编辑快捷键合集</h2><h3 id="1-Alt-鼠标点击"><a href="#1-Alt-鼠标点击" class="headerlink" title="1. Alt + 鼠标点击"></a>1. Alt + 鼠标点击</h3><blockquote><p>能够实现在每一个点击的地方添加输入光标</p></blockquote><h3 id="2-Alt-Shift-鼠标左键按住拖动"><a href="#2-Alt-Shift-鼠标左键按住拖动" class="headerlink" title="2. Alt + Shift + 鼠标左键按住拖动"></a>2. Alt + Shift + 鼠标左键按住拖动</h3><blockquote><p>竖列多行选择。先选择起始点，然后按住 <code>Alt + Shift</code> 加上左键按住拖动。</p></blockquote><h3 id="3-鼠标-中键-选中多行"><a href="#3-鼠标-中键-选中多行" class="headerlink" title="3. 鼠标 中键 选中多行"></a>3. 鼠标 中键 选中多行</h3><blockquote><p>效果和 <code>Alt + Shift + 鼠标左键按住拖动</code> 一样，不过不用先选择起始点，而是鼠标浮动那哪里，按住鼠标中键，起始点就是哪里。</p></blockquote><h3 id="4-Ctrl-D"><a href="#4-Ctrl-D" class="headerlink" title="4. Ctrl + D"></a>4. Ctrl + D</h3><blockquote><p>逐一查找并选中，您选中的内容。</p></blockquote><h3 id="5-Ctrl-U"><a href="#5-Ctrl-U" class="headerlink" title="5. Ctrl + U"></a>5. Ctrl + U</h3><blockquote><p>回退到上一个 <code>Ctrl + U</code> 选中的内容</p></blockquote><h3 id="6-Ctrl-Shift-L"><a href="#6-Ctrl-Shift-L" class="headerlink" title="6. Ctrl + Shift + L"></a>6. Ctrl + Shift + L</h3><blockquote><p>类似 <code>Ctrl + D</code> ,不过这是立即选中全部匹配项</p></blockquote><h3 id="7-Ctrl-Shift-P"><a href="#7-Ctrl-Shift-P" class="headerlink" title="7. Ctrl + Shift + P"></a>7. Ctrl + Shift + P</h3><blockquote><p>临时新增一个 实现<code>Markdown</code>文档的实时预览</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Visual Studio Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio Code </tag>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello-world</title>
      <link href="/2021/10/20/hello-world/"/>
      <url>/2021/10/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hello-world </tag>
            
            <tag> first </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6 笔记之第十章 对象的扩展</title>
      <link href="/2021/10/19/es6-10/"/>
      <url>/2021/10/19/es6-10/</url>
      
        <content type="html"><![CDATA[<h2 id="1-属性的简洁表示"><a href="#1-属性的简洁表示" class="headerlink" title="1. 属性的简洁表示"></a>1. 属性的简洁表示</h2><p>ES6允许直接在大括号里边书写变量和函数，作为对象的属性和方法。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;demo1const foo &#x3D; &#39;bar&#39;;const baz &#x3D; &#123;foo&#125;baz  &#x2F;&#x2F;&#123;foo:&quot;bar&quot;&#125;&#x2F;&#x2F;等同于const baz &#x3D; &#123;foo:foo&#125;&#x2F;&#x2F;demo2function f(x,y)&#123;  return &#123;x,y&#125;&#125;&#x2F;&#x2F;等同于function f(x,y)&#123;  return &#123;x:x,y:y&#125;&#125;f(1,2) &#x2F;&#x2F;Object &#123;x:1,y:2&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>*，简写的对象方法不能用作构造函数，会报错。</p><pre class="line-numbers language-none"><code class="language-none">const obj &#x3D; &#123;  f() &#123;    this.foo &#x3D; &#39;bar&#39;;  &#125;&#125;;new obj.f() &#x2F;&#x2F; 报错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-属性名表达式"><a href="#2-属性名表达式" class="headerlink" title="2. 属性名表达式"></a>2. 属性名表达式</h2><p>JavaScript定义对象的属性，有两种方法。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;方法一 直接用标识符作为属性名obj.foo &#x3D; true;&#x2F;&#x2F;方法二 用表达式作为属性名，这是要把表达式放在方括号之内obj[&#39;a&#39; + &#39;bc&#39;] &#x3D; 123;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong> 属性名表达式与简洁表达式，不能同时使用</p><h2 id="3-方法的name属性"><a href="#3-方法的name属性" class="headerlink" title="3. 方法的name属性"></a>3. 方法的name属性</h2><p>函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。</p><p>所以，name属性可以返回函数名也可以返回方法名</p><p>对象的方法使用了取值函数(getting)和存值函数(setting)，name属性不是在该方法上面，而是在方法属性的描述对象的get和set属性上面，返回的是方法名上加get和set</p><pre class="line-numbers language-none"><code class="language-none">const obj &#x3D; &#123;  get foo() &#123;&#125;,  set foo(x) &#123;&#125;&#125;;obj.foo.name&#x2F;&#x2F; TypeError: Cannot read property &#39;name&#39; of undefinedconst descriptor &#x3D; Object.getOwnPropertyDescriptor(obj, &#39;foo&#39;);descriptor.get.name &#x2F;&#x2F; &quot;get foo&quot;descriptor.set.name &#x2F;&#x2F; &quot;set foo&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有两种特殊情况：</p><p>bind方法创造的函数，name属性返回bound加上原函数的名字。</p><p>Function构造函数创造的函数，name属性返回anonymous</p><pre class="line-numbers language-none"><code class="language-none">(new Function()).name &#x2F;&#x2F; &quot;anonymous&quot;var doSomething &#x3D; function() &#123;  &#x2F;&#x2F; ...&#125;;doSomething.bind().name &#x2F;&#x2F; &quot;bound doSomething&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果对象的方法是一个Symbol值，那么那么属性返回的是这个Symbol值得描述。</p><pre class="line-numbers language-none"><code class="language-none">const key1 &#x3D; Symbol(&#39;description&#39;);const key2 &#x3D; Symbol();let obj &#x3D; &#123;  [key1]() &#123;&#125;,  [key2]() &#123;&#125;,&#125;;obj[key1].name &#x2F;&#x2F; &quot;[description]&quot;obj[key2].name &#x2F;&#x2F; &quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>key1队形的Symbol值有描述，key2没有。</p><h2 id="4-属性的可枚举性和遍历"><a href="#4-属性的可枚举性和遍历" class="headerlink" title="4. 属性的可枚举性和遍历"></a>4. 属性的可枚举性和遍历</h2><h3 id="4-1-可枚举型"><a href="#4-1-可枚举型" class="headerlink" title="4.1 可枚举型"></a>4.1 可枚举型</h3><p>对象的每个属性都有一个描述对象，用来控制属性的行为。</p><p>Object.getOwnPropertyDescriptor方法可以获取该属性的描述方法。</p><pre class="line-numbers language-none"><code class="language-none">let obj &#x3D; &#123;foo:123&#125;;Object.getOwnPropertyDescriptor(obj,&#39;foo&#39;)&#x2F;&#x2F;  &#123;&#x2F;&#x2F;    value: 123,&#x2F;&#x2F;    writable: true,&#x2F;&#x2F;    enumerable: true,&#x2F;&#x2F;    configurable: true&#x2F;&#x2F;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>描述对象的enumerable属性，成为可枚举，如果该属性为 false，表示某些属性操作会忽略当前属性。</p><p>目前，有四个操作会忽略enumerable为false的属性。</p><ul><li>for…in循环：只遍历对象自身的和继承的可枚举的属性。</li><li>Object.keys()：返回对象自身的所有可枚举的属性的键名。</li><li>JSON.stringify()：只串行化对象自身的可枚举的属性。</li><li>Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。</li></ul><h3 id="4-2-属性的遍历"><a href="#4-2-属性的遍历" class="headerlink" title="4.2 属性的遍历"></a>4.2 属性的遍历</h3><p>ES6一共有5种方法可以遍历对象的属性<br>(1) for…in  循环遍历对象自身的和继承的可枚举属性（不包含Symbol属性）</p><p>(2) Object.keys(obj)  返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不包含Symbol属性）的键名</p><p>(3) Object.getOwnPropertyNames(obj)  返回一个数组，包括对象自身的所有属性（不包含Symbol属性，但是包含不可枚举属性）的键名</p><p>(4) Object.getOwnPropertySymbols(obj)  返回一个数组，包含对象自身的所有Symbol属性的键名。</p><p>(5) Reflect.ownKeys(obj)  返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p><p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p><ul><li>首先遍历所有数值键，按照数值升序排列。</li><li>其次遍历所有字符串键，按照加入时间升序排列。</li><li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li></ul><pre class="line-numbers language-none"><code class="language-none">Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)&#x2F;&#x2F; [&#39;2&#39;, &#39;10&#39;, &#39;b&#39;, &#39;a&#39;, Symbol()]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>返回一个数组，包含参数对象的所有属性，次序为：首先数值属性2和10，其次字符串属性b和a，最后是Symbol属性。</p><h2 id="5-super关键字"><a href="#5-super关键字" class="headerlink" title="5. super关键字"></a>5. super关键字</h2><p>this 关键字 总是指向函数所在的当前对象，ES6有新增了另一个类似关键字 super ，指向当前对象的原型对象。</p><pre class="line-numbers language-none"><code class="language-none">const proto &#x3D; &#123;  foo: &#39;hello&#39;&#125;;const obj &#x3D; &#123;  foo: &#39;world&#39;,  find() &#123;    return super.foo;  &#125;&#125;;&#x2F;&#x2F;通过super.foo 引用了原型对象proto的foo属性。Object.setPrototypeOf(obj, proto);obj.find() &#x2F;&#x2F; &quot;hello&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Object.setPrototypeOf() 方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或  null。</p><p>obj  要设置其原型的对象。prototype  该对象的新原型(一个对象 或 null).</p><p><strong>注意</strong> super关键字表示原型对象时，只能用在对象的方法中，用在其他方法都会报错，</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 报错  super用在属性里边const obj &#x3D; &#123;  foo: super.foo&#125;&#x2F;&#x2F; 报错  super用在一个函数里面，然后赋值给foo属性。const obj &#x3D; &#123;  foo: () &#x3D;&gt; super.foo&#125;&#x2F;&#x2F; 报错  super用在一个函数里面，然后赋值给foo属性。const obj &#x3D; &#123;  foo: function () &#123;    return super.foo  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>JavaScript 引擎内部，super.foo等同于Object.getPrototypeOf(this).foo（属性）或Object.getPrototypeOf(this).foo.call(this)（方法）。</p><pre class="line-numbers language-none"><code class="language-none">const proto &#x3D; &#123;  x: &#39;hello&#39;,  foo() &#123;    console.log(this.x);  &#125;,&#125;;const obj &#x3D; &#123;  x: &#39;world&#39;,  foo() &#123;    super.foo();  &#125;&#125;Object.setPrototypeOf(obj, proto);obj.foo() &#x2F;&#x2F; &quot;world&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中，super.foo指向原型对象proto的foo方法，但是绑定的this却还是当前对象obj，因此输出的就是world。</p><p>this 关键字 谁调用指向谁</p>]]></content>
      
      
      <categories>
          
          <category> ES6 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
